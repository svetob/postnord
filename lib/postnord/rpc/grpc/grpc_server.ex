defmodule Postnord.GRPC.Node.Server do
  alias Postnord.Consumer.PartitionConsumer
  alias Postnord.GRPC.ConfirmRequest
  alias Postnord.GRPC.ConfirmReply
  alias Postnord.GRPC.ReadReply
  alias Postnord.GRPC.ReplicateReply
  alias Postnord.GRPC.TombstoneReply
  alias Postnord.GRPC.WriteReply
  alias Postnord.Partition
  alias Postnord.RPC.Coordinator
  require Logger
  use GRPC.Server, service: Postnord.GRPC.Node.Service

  @moduledoc """
  gRPC server implementation.

  Template generated by `mix grpc.gen.server`.
  """

  def write(write_request, _stream) do
    case Coordinator.write_message(write_request.queue, write_request.message) do
      :ok ->
        WriteReply.new(response: :OK)
      {:error, reason} ->
        WriteReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def read(read_request, _stream) do
    case Coordinator.read_message(read_request.queue) do
      {:ok, id, message} ->
        ReadReply.new(response: :OK, id: id, message: message)
      :empty ->
        ReadReply.new(response: :EMPTY)
      {:error, reason} ->
        ReadReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def confirm(confirm_request, _stream) do
    handle_confirm(confirm_request)
  end

  defp handle_confirm(%ConfirmRequest{confirmation: :ACCEPT, id: id}) do
    case PartitionConsumer.accept(PartitionConsumer, id) do
      res when res in [:ok, :noop]  ->
        ConfirmReply.new(response: :OK)
      {:error, reason} ->
        ConfirmReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def replicate(replicate_request, _stream) do
    case Partition.replicate_message(Partition, replicate_request.id, replicate_request.message) do
      :ok ->
        ReplicateReply.new(response: :OK)
      {:error, reason} ->
        ReplicateReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def acquire_hold(acquire_hold_request, _stream) do
  end

  def tombstone(tombstone_request, _stream) do
    case PartitionConsumer.accept(PartitionConsumer, tombstone_request.id) do
      res when res in [:ok, :noop] -> TombstoneReply.new(success: true)
    end
  end


  defp error_message(reason) when is_binary(reason) or is_bitstring(reason) do
    reason
  end
  defp error_message(reason) do
    inspect(reason)
  end

end
