defmodule Postnord.GRPC.Node.Server do
  alias Postnord.Consumer.PartitionConsumer
  alias Postnord.GRPC.ConfirmRequest
  alias Postnord.GRPC.ConfirmReply
  alias Postnord.GRPC.FlushRequest
  alias Postnord.GRPC.GenericReply
  alias Postnord.GRPC.ReadRequest
  alias Postnord.GRPC.ReadReply
  alias Postnord.GRPC.ReplicateRequest
  alias Postnord.GRPC.ReplicateReply
  alias Postnord.GRPC.TombstoneRequest
  alias Postnord.GRPC.WriteRequest
  alias Postnord.GRPC.WriteReply
  alias Postnord.Partition
  alias Postnord.RPC.Coordinator
  require Logger
  use GRPC.Server, service: Postnord.GRPC.Node.Service

  @moduledoc """
  gRPC server implementation.

  Template generated by `mix grpc.gen.server`.

  To update PB module with postnord.proto changes:

      mix grpc.gen priv/protos/postnord.proto --out lib/postnord/rpc/grpc
  """

  def write(%WriteRequest{queue: queue, message: message}, _stream) do
    Logger.debug "#{__MODULE__} Write request received"
    case Coordinator.write_message(queue, message) do
      :ok ->
        Logger.debug "#{__MODULE__} :OK reply"
        WriteReply.new(response: :OK)
      {:error, reason} ->
        Logger.debug "#{__MODULE__} :ERROR reply"
        WriteReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def read(%ReadRequest{queue: queue}, _stream) do
    Logger.debug "#{__MODULE__} Read request received"
    case Coordinator.read_message(queue) do
      {:ok, id, message} ->
        ReadReply.new(response: :OK, id: id, message: message)
      :empty ->
        ReadReply.new(response: :EMPTY)
      {:error, reason} ->
        ReadReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def confirm(%ConfirmRequest{} = confirm_request, _stream) do
    Logger.debug "#{__MODULE__} Confirm request received"
    handle_confirm(confirm_request)
  end

  defp handle_confirm(%ConfirmRequest{confirmation: :ACCEPT, id: id, queue: queue}) do
    Logger.debug "#{__MODULE__} Confirm :ACCEPT request received"

    case Coordinator.confirm_accept(queue, id) do
      :ok  ->
        ConfirmReply.new(response: :OK)
      {:error, reason} ->
        ConfirmReply.new(response: :ERROR, error_message: error_message(reason))
    end
  end

  def flush(%FlushRequest{queue: queue}, _stream) do
    Logger.debug "#{__MODULE__} Flush request received"

    queue
    |> Coordinator.flush()
    |> generic_reply()
  end

  def replicate(%ReplicateRequest{id: id, timestamp: timestamp, message: message}, _stream) do
    Logger.debug "#{__MODULE__} Replicate request received"

    Partition
    |> Partition.replicate_message(id, timestamp, message)
    |> generic_reply()
  end

  def replicate_flush(%FlushRequest{queue: _queue}, _stream) do
    Logger.debug "#{__MODULE__} Replicate flush request received"

    PartitionConsumer
    |> PartitionConsumer.flush()
    |> generic_reply()
  end

  def acquire_hold(acquire_hold_request, _stream) do
  end

  def tombstone(%TombstoneRequest{partition: _partition, id: id}, _stream) do
    Logger.debug "#{__MODULE__} Tombstone request received"

    PartitionConsumer
    |> PartitionConsumer.accept(id)
    |> generic_reply()
  end


  defp generic_reply(:ok) do
    GenericReply.new(success: true)
  end
  defp generic_reply(:noop) do
    GenericReply.new(success: true)
  end
  defp generic_reply({:error, reason}) do
    GenericReply.new(error_message: error_message(reason))
  end

  defp error_message(reason) when is_binary(reason) or is_bitstring(reason) do
    reason
  end
  defp error_message(reason) do
    inspect(reason)
  end

end
